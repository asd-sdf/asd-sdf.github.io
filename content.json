[{"title":"LG3586","date":"2019-03-13T15:45:11.000Z","path":"2019/03/13/LG3586/","text":"使用SBT来求大于s的个数，和小于s的数的和 操作1：单点修改，若之前的数是正数，第一个树状数组-1，第二个树状数组$-$原来的数，若之后的数是正数，第一个树状数组+1，第二个树状数组+之后的数 操作2：区间询问，先将大于s的个数求出来，再比较c-大于s的个数乘上c与剩余数之和，若前者大，输出NIE，否则输出TAK 先将大于s的个数求出来，再比较c-大于s的个数乘上s与剩余数之和，若前者大，输出NIE，否则输出TAKCode: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e6+5;typedef long long ll;int val[N],cnt[N],siz[N],c[N][2],root,tot;ll sum[N];inline void up(int x)&#123; sum[x]=sum[c[x][0]]+sum[c[x][1]]+1ll*val[x]*cnt[x]; siz[x]=siz[c[x][0]]+siz[c[x][1]]+cnt[x];&#125;inline void rot(int &amp;x,int k)&#123; k^=1; int y=c[x][k]; c[x][k]=c[y][k^1]; c[y][k^1]=x; up(x);up(y); x=y;&#125;inline void maintain(int &amp;x)&#123; if(x==0)return ; bool flag1=0,flag2=0; if(siz[c[c[x][0]][0]]&gt;siz[c[x][1]]) rot(x,1),flag2=1; else if(siz[c[c[x][0]][1]]&gt;siz[c[x][1]]) rot(c[x][0],0),rot(x,1),flag1=flag2=1; if(siz[c[c[x][1]][1]]&gt;siz[c[x][0]]) rot(x,0),flag1=1; else if(siz[c[c[x][1]][0]]&gt;siz[c[x][0]]) rot(c[x][1],1),rot(x,0),flag1=flag2=1; up(x); if(flag1)maintain(c[x][0]); if(flag2)maintain(c[x][1]); up(x);&#125;inline void insert(int x,int &amp;now)&#123; if(!now) &#123; now=++tot; val[now]=x; &#125; if(val[now]==x) &#123; ++cnt[now];up(now); return ; &#125; if(x&lt;val[now]) insert(x,c[now][0]); else insert(x,c[now][1]); maintain(now); maintain(now); up(now);&#125;inline void ins(int x)&#123;insert(x,root);&#125;inline int Delete(int x,int &amp;now)&#123; int tmp; if(x==val[now]||(x&lt;val[now]&amp;&amp;!c[now][0])||(x&gt;val[now]&amp;&amp;!c[now][1])) &#123; tmp=val[now]; if(cnt[now]&gt;1) --cnt[now]; else if(!c[now][0]||!c[now][1]) now=c[now][0]+c[now][1]; else val[now]=Delete(val[now]+1,c[now][0]); up(now); return tmp; &#125; if(x&lt;val[now])tmp=Delete(x,c[now][0]); else tmp=Delete(x,c[now][1]); up(now); return tmp;&#125;inline void del(int x)&#123;Delete(x,root);&#125;inline ll gsum(int x,bool flag)&#123; int now=root; ll ans1=0,ans2=0; while(now) &#123; if(val[now]==x) &#123; ans1+=sum[c[now][0]]; ans2+=sum[c[now][1]]; break; &#125; if(val[now]&lt;x) &#123; ans1+=sum[now]-sum[c[now][1]]; now=c[now][1]; &#125; else &#123; ans2+=sum[now]-sum[c[now][0]]; now=c[now][0]; &#125; &#125; if(!flag)return ans1; return ans2;&#125;inline int gsiz(int x,bool flag)&#123; int now=root; ll ans1=0,ans2=0; while(now) &#123; if(val[now]==x) &#123; ans1+=siz[c[now][0]]; ans2+=siz[c[now][1]]; break; &#125; if(val[now]&lt;x) &#123; ans1+=siz[now]-siz[c[now][1]]; now=c[now][1]; &#125; else &#123; ans2+=siz[now]-siz[c[now][0]]; now=c[now][0]; &#125; &#125; if(!flag)return ans1; return ans2;&#125;inline int rd()&#123; int x=0,fl=1;char ch=getchar(); for(;ch&gt;'9'||ch&lt;'0';ch=getchar())fl=(ch=='-'?-1:1); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())x=x*10+ch-'0'; return x*fl;&#125;int n,m,a[N],b[N];int main()&#123; n=rd();m=rd(); int x,y,z; char opt; while(m--) &#123; cin&gt;&gt;opt;x=rd();y=rd(); if(opt=='U') &#123; if(!b[x]) &#123; ins(y); a[x]=y; b[x]=1; &#125; else &#123; del(a[x]);a[x]=y; ins(y); &#125; &#125; else &#123; z=gsiz(y-1,1); x-=z; if(1ll*x*y&lt;=gsum(y,0)) puts(\"TAK\"); else puts(\"NIE\"); &#125; &#125; return 0;&#125;","updated":"2019-03-13T15:50:23.988Z","comments":true,"link":"","excerpt":"","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://yoursite.com/categories/Luogu/"}],"tags":[{"name":"SBT","slug":"SBT","permalink":"http://yoursite.com/tags/SBT/"},{"name":"平衡树","slug":"平衡树","permalink":"http://yoursite.com/tags/平衡树/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"LG1351","date":"2019-03-13T15:42:10.000Z","path":"2019/03/13/LG1351/","text":"提供一个好思路 首先共n个点,n-1条边，肯定为树，即没有环。那么距离为2，就是一个点连接的两个点，求联合权值即可。 But:O(n^2) TLE 那咋办？我们来优化一下。 最大： 一个点连接的两个权值最大的点，其联合权值再与ans1取max两个权值最大的点在输入的时候就搞定 O(n) 和： 即为一个点连接的两个点的联合权值之和，然后再取和。那咋求？ 易得 S(一个点连接的两个点的联合权值之和)=A{一个点连接的点）*（W(一个点连接的点的权值和）-A) S=A*W-A^2; S总=W^2-A总^2; W可在建边时搞定，同时处理A总^2。O(n) 搞定! 献上丑陋的代码：12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200005,M=N&lt;&lt;1,P=10007;int w[N],s[N],s1[N],m1[N],m2[N],xx[N],yy[N],ans1,ans2,n;inline void bia(int x,int y)&#123; s[x]+=w[y]%P,s[x]%=P; s1[x]+=(w[y]*w[y])%P,s1[x]%=P; if(w[y]&gt;m1[x]) m2[x]=m1[x],m1[x]=w[y]; else if(w[y]&gt;m2[x]) m2[x]=w[y];&#125;inline void ad(int x,int y)&#123; bia(x,y); bia(y,x);&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;n;i++) cin&gt;&gt;xx[i]&gt;&gt;yy[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; for(int i=1;i&lt;n;i++) ad(xx[i],yy[i]); for(int i=1;i&lt;=n;i++) &#123; ans1=max(ans1,m1[i]*m2[i]); ans2+=((s[i]*s[i])-s1[i])%P; ans2%=P; &#125; cout&lt;&lt;ans1&lt;&lt;\" \"&lt;&lt;ans2&lt;&lt;endl; return 0;&#125;","updated":"2019-03-13T15:46:35.769Z","comments":true,"link":"","excerpt":"","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://yoursite.com/categories/Luogu/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"树的遍历","slug":"树的遍历","permalink":"http://yoursite.com/tags/树的遍历/"}]},{"title":"LG1908","date":"2019-03-13T15:38:42.000Z","path":"2019/03/13/LG1908/","text":"其实就是求逆序对。而逆序对就是求每一个数前面有多少个比它大，则考虑权值线段树。什么是权值线段树？ 就是以数的大小作区间的线段树。然而，此题数据范围太大，所以需要一个小小的预处理操作：例：2 8 0 3 2，我们可以排个序（要保留原版）：0 2 2 3 8去重：0 2 3 8，编号为：1，2，3，4。再对应回去：2 4 1 3 2(要开个结构体，记录原位置）一系列骚操作得： $1&lt;=A_i&lt;=n​$好了，现在可以构造了。（值都为0） 查询逆序对，先从前向后依次查询，记录总和，查询后加入线段树并回溯 献上丑陋的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int rd()&#123; int x=0,flag=1; char ch=getchar(); while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') flag=-1,ch=getchar(); while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=x*10+ch-'0',ch=getchar(); return x*flag;&#125;inline LL rdl()&#123; LL x=0,flag=1; char ch=getchar(); while((ch&lt;'0' || ch&gt;'9') &amp;&amp; ch!='-') ch=getchar(); if(ch=='-') flag=-1,ch=getchar(); while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=x*10+ch-'0',ch=getchar(); return x*flag;&#125;//读入优化const int N=5e5+50;const int TR=N&lt;&lt;2;struct tree&#123; int l,r,k;&#125;t[TR];inline int ls(int x)//左儿子&#123; return x&lt;&lt;1;&#125;inline int rs(int x)//右儿子&#123; return x&lt;&lt;1|1;&#125;struct no&#123; int x,i;&#125;cop[N];bool comp(no x,no y)&#123; return x.x&lt;y.x;&#125;inline void build(int now,int l,int r)//建树&#123; t[now].l=l; t[now].r=r; t[now].k=0; if(l==r) return ; int mid=(l+r)&gt;&gt;1; build(ls(now),l,mid); build(rs(now),mid+1,r); return ;&#125;inline void up(int now)//回溯&#123; t[now].k=t[rs(now)].k+t[ls(now)].k;&#125;inline LL src(int now,int x)//搜索&#123; int l=t[now].l,r=t[now].r; LL sum=0; int mid=(l+r)&gt;&gt;1; if(l==r) return (LL)t[now].k; if(x&lt;=mid) sum+=(LL)t[rs(now)].k+src(ls(now),x);//若在左儿子中，右儿子一定比它大 else sum+=src(rs(now),x);//搜索右儿子 return sum;&#125;inline void upate(int now,int x)//加入&#123; int l=t[now].l,r=t[now].r; int mid=(l+r)&gt;&gt;1; if(l==r) &#123; t[now].k++;//统计个数 return ; &#125; if(x&lt;=mid) upate(ls(now),x); else upate(rs(now),x); up(now);&#125;int n;LL a[N],k[N],tot=0,ans=0;//开long long防爆int main()&#123; n=rd(); for(int i=1;i&lt;=n;i++) a[i]=rdl(),cop[i].x=a[i],cop[i].i=i; sort(cop+1,cop+n+1,comp); for(int i=1;i&lt;=n;i++) &#123; if(cop[i].x!=cop[i-1].x || i==1) k[++tot]=cop[i].x; a[cop[i].i]=tot; &#125;//预处理 build(1,1,n); for(int i=1;i&lt;=n;i++) &#123; ans+=src(1,a[i]+1);//大于a的个数=大于等于a+1的个数 upate(1,a[i]);//更新 &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","updated":"2019-03-13T15:41:19.400Z","comments":true,"link":"","excerpt":"","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://yoursite.com/categories/Luogu/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"逆序对","slug":"逆序对","permalink":"http://yoursite.com/tags/逆序对/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"LG1401","date":"2019-03-10T15:14:23.000Z","path":"2019/03/10/LG1401/","text":"网路流为啥要二分？？？我们可以将边按边权排序，然后从1开始枚举验证。此处就不讲怎么建图了，（将容量设为一即可） 问题来了：此时时间复杂度：$O(nm^2)$? 错了我们不必重新建图，然后重新跑dinic我们可以利用上一次dinic所剩下的残余网络在里面加新增的边，直接跑dinic，求出新增的路径个数问题就解决了。。。时间复杂度为：$O(nm)$ Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5;int fi[N],ne[N],to[N],w[N],tot=1;inline void add(int x,int y,int z)&#123;ne[++tot]=fi[x];to[tot]=y;w[tot]=z;fi[x]=tot;&#125;inline void ad(int x,int y,int z)&#123;add(x,y,z);add(y,x,z);&#125;int dis[N],s,t;bool bfs()&#123; memset(dis,0,sizeof(dis)); queue&lt;int&gt;q; q.push(s); dis[s]=1; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int i=fi[x];i;i=ne[i]) &#123; int y=to[i]; if(w[i]&amp;&amp;!dis[y]) &#123; dis[y]=dis[x]+1; if(y==t)return 1; q.push(y); &#125; &#125; &#125; return 0;&#125;int dfs(int x,int flow)&#123; if(x==t||flow==0)return flow; int res=0,u; for(int i=fi[x];i;i=ne[i]) &#123; int y=to[i]; if(dis[y]==dis[x]+1) &#123; u=dfs(y,min(flow,w[i])); res+=u;flow-=u;w[i]-=u;w[i^1]+u; if(!flow)break; &#125; &#125; if(flow)dis[x]=-1; return res;&#125;int dinic()&#123; int mf=0,x; while(bfs()) while(x=dfs(s,INT_MAX)) mf+=x; return mf;&#125;struct edge&#123; int x,y,z;&#125;e[N];bool cmp(edge x,edge y)&#123;return x.z&lt;y.z;&#125;int n,m,T;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;T); s=1;t=n; int now=1; for(int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;e[i].x,&amp;e[i].y,&amp;e[i].z); sort(e+1,e+m+1,cmp); for(int i=1;;i++) &#123; for(;now&lt;=m&amp;&amp;e[now].z&lt;=i;now++) ad(e[now].x,e[now].y,1); T-=dinic(); if(T&lt;=0) &#123; printf(\"%d\\n\",i); return 0; &#125; &#125; return 0;&#125;","updated":"2019-03-11T13:47:19.400Z","comments":true,"link":"","excerpt":"","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://yoursite.com/categories/Luogu/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"残余网络","slug":"残余网络","permalink":"http://yoursite.com/tags/残余网络/"}]},{"title":"LG4899","date":"2019-03-10T15:11:16.000Z","path":"2019/03/10/LG4899/","text":"这道题三个用主席树的理由： 解题需求 （废话） 复杂度小 $O(nlogn)$ 强制在线 Step1：我们可以先kruskal重构两棵树：A树非根节点大于父节点，BB树非根节点小于父节点。我们发现这两棵树有一个性质：一个子树内任意节点可以仅通过子树内的节点到达子树内的任意节点，也就是说，每个子树都是联通的且编号满足堆的性质。那么，我们可以现在A树中找到$S$，倍增跳到$X$,使$X&gt;=L,Fa_X&lt;L$则$S$可以只通过编号大于等于$L$的点所能到的点的集合是$X$的子树内所有点的集合,令为$Vs$。同理我们可以得到$T$只经过编号小于等于$R$的点所能到的点的集合$Vt$。求是否有解即为这两个集合是否公共点。 Step2：分别处理出A树和B树的dfs序：dfa,dfb.$Vs$的dfa在$dfa_X$~$dfa_X+siz_X-1$$Vt$的dfb在$dfb_Y$~$dfa_Y+siz_Y-1$建立结构体，按dfa排序，以dfb为权值建立主席树查询$dfa_X$~$dfa_X+siz_X-1$的主席树中值在$dfb_Y$~$dfa_Y+siz_Y-1$之间的个数。若为0则输出0，否则输出1.解毕。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;const int N=8e5+5;const int T=N&lt;&lt;4;int n,m,q,fi[N],ne[N],to[N],tot;int dfa[N],dfb[N],sia[N],sib[N];void add(int x,int y)&#123;ne[++tot]=fi[x];to[tot]=y;fi[x]=tot;&#125;void ad(int x,int y)&#123;add(x,y);add(y,x);&#125;struct kruskal&#123; int type,fk[N],nk[N],tk[N],tok; int fa[N],jp[N][20],rt,dfn[N],cnt,siz[N]; void adk(int x,int y)&#123;nk[++tok]=fk[x];tk[tok]=y;fk[x]=tok;&#125; int fd(int x) &#123; if(x!=fa[x])fa[x]=fd(fa[x]); return fa[x]; &#125; void dfs(int x) &#123; dfn[x]=++cnt;siz[x]=1; for(int i=fk[x];i;i=nk[i]) &#123; int y=tk[i]; jp[y][0]=x; dfs(y); siz[x]+=siz[y]; &#125; &#125; void build() &#123; for(int i=1;i&lt;=n;i++)fa[i]=i; if(type==1) for(int x=n;x;x--) for(int i=fi[x];i;i=ne[i]) &#123; int y=to[i]; if(y&gt;x) &#123; int fx=fd(x),fy=fd(y); if(fx==fy)continue; fa[fy]=fx; adk(fx,fy); &#125; &#125; else for(int x=1;x&lt;=n;x++) for(int i=fi[x];i;i=ne[i]) &#123; int y=to[i]; if(y&lt;x) &#123; int fx=fd(x),fy=fd(y); if(fx==fy)continue; fa[fy]=fx; adk(fx,fy); &#125; &#125; cnt=0; rt=fd(1); dfs(rt); for(int j=1;j&lt;=18;j++) for(int i=1;i&lt;=n;i++) jp[i][j]=jp[jp[i][j-1]][j-1]; &#125; int lca(int x,int y) &#123; for(int i=18;i&gt;=0;i--) &#123; if(type==1) &#123; if(jp[x][i]&gt;=y) x=jp[x][i]; &#125; else &#123; if(jp[x][i]&lt;=y &amp;&amp; jp[x][i]) x=jp[x][i]; &#125; &#125; return x; &#125;&#125;A,B;struct DFN&#123; int a,b;&#125;ss[N];bool cmp(DFN x,DFN y)&#123;return x.a&lt;y.a;&#125;int ls[T],rs[T],tr[T],rt[N],t_cnt;void build(int pre,int &amp;now,int l,int r,int x)&#123; now=++t_cnt;tr[now]=tr[pre]+1; if(l==r)return ; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) &#123; rs[now]=rs[pre]; build(ls[pre],ls[now],l,mid,x); &#125; else &#123; ls[now]=ls[pre]; build(rs[pre],rs[now],mid+1,r,x); &#125; return ;&#125;int query(int now1,int now2,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; R&gt;=r) return tr[now2]-tr[now1]; int mid=(l+r)&gt;&gt;1,anss=0; if(L&lt;=mid)anss+=query(ls[now1],ls[now2],l,mid,L,R); if(R&gt;mid)anss+=query(rs[now1],rs[now2],mid+1,r,L,R); return anss;&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q); int x,y,z,v; for(int i=1;i&lt;=m;i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); ad(x+1,y+1); &#125; A.type=1; A.build(); B.type=0; B.build(); for(int i=1;i&lt;=n;i++) &#123; dfa[i]=A.dfn[i];sia[i]=A.siz[i]; dfb[i]=B.dfn[i];sib[i]=B.siz[i]; ss[i].a=dfa[i]; ss[i].b=dfb[i]; &#125; sort(ss+1,ss+n+1,cmp); for(int i=1;i&lt;=n;i++) build(rt[i-1],rt[i],1,n,ss[i].b); for(int i=1;i&lt;=q;i++) &#123; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;z,&amp;v); x++;y++;z++;v++; x=A.lca(x,z); y=B.lca(y,v); if(query(rt[dfa[x]-1],rt[dfa[x]+sia[x]-1],1,n,dfb[y],dfb[y]+sib[y]-1)) puts(\"1\"); else puts(\"0\"); &#125; return 0;&#125;","updated":"2019-03-11T13:13:20.919Z","comments":true,"link":"","excerpt":"","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://yoursite.com/categories/Luogu/"}],"tags":[{"name":"kruskal","slug":"kruskal","permalink":"http://yoursite.com/tags/kruskal/"},{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"dfs序","slug":"dfs序","permalink":"http://yoursite.com/tags/dfs序/"}]}]