<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LG1401]]></title>
    <url>%2F%2F</url>
    <content type="text"><![CDATA[网路流为啥要二分？？？我们可以将边按边权排序，然后从1开始枚举验证。此处就不讲怎么建图了，（将容量设为一即可） 问题来了：此时时间复杂度：$O(nm^2)$? 错了我们不必重新建图，然后重新跑dinic我们可以利用上一次dinic所剩下的残余网络在里面加新增的边，直接跑dinic，求出新增的路径个数问题就解决了。。。时间复杂度为：$O(nm)$ Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5;int fi[N],ne[N],to[N],w[N],tot=1;inline void add(int x,int y,int z)&#123;ne[++tot]=fi[x];to[tot]=y;w[tot]=z;fi[x]=tot;&#125;inline void ad(int x,int y,int z)&#123;add(x,y,z);add(y,x,z);&#125;int dis[N],s,t;bool bfs()&#123; memset(dis,0,sizeof(dis)); queue&lt;int&gt;q; q.push(s); dis[s]=1; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int i=fi[x];i;i=ne[i]) &#123; int y=to[i]; if(w[i]&amp;&amp;!dis[y]) &#123; dis[y]=dis[x]+1; if(y==t)return 1; q.push(y); &#125; &#125; &#125; return 0;&#125;int dfs(int x,int flow)&#123; if(x==t||flow==0)return flow; int res=0,u; for(int i=fi[x];i;i=ne[i]) &#123; int y=to[i]; if(dis[y]==dis[x]+1) &#123; u=dfs(y,min(flow,w[i])); res+=u;flow-=u;w[i]-=u;w[i^1]+u; if(!flow)break; &#125; &#125; if(flow)dis[x]=-1; return res;&#125;int dinic()&#123; int mf=0,x; while(bfs()) while(x=dfs(s,INT_MAX)) mf+=x; return mf;&#125;struct edge&#123; int x,y,z;&#125;e[N];bool cmp(edge x,edge y)&#123;return x.z&lt;y.z;&#125;int n,m,T;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;T); s=1;t=n; int now=1; for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].z); sort(e+1,e+m+1,cmp); for(int i=1;;i++) &#123; for(;now&lt;=m&amp;&amp;e[now].z&lt;=i;now++) ad(e[now].x,e[now].y,1); T-=dinic(); if(T&lt;=0) &#123; printf("%d\n",i); return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>残余网络</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LG4899]]></title>
    <url>%2F%2F</url>
    <content type="text"><![CDATA[这道题三个用主席树的理由： 解题需求 （废话） 复杂度小 $O(nlogn)$ 强制在线 Step1：我们可以先kruskal重构两棵树：A树非根节点大于父节点，BB树非根节点小于父节点。我们发现这两棵树有一个性质：一个子树内任意节点可以仅通过子树内的节点到达子树内的任意节点，也就是说，每个子树都是联通的且编号满足堆的性质。那么，我们可以现在A树中找到$S$，倍增跳到$X$,使$X&gt;=L,Fa_X&lt;L$则$S$可以只通过编号大于等于$L$的点所能到的点的集合是$X$的子树内所有点的集合,令为$Vs$。同理我们可以得到$T$只经过编号小于等于$R$的点所能到的点的集合$Vt$。求是否有解即为这两个集合是否公共点。 Step2：分别处理出A树和B树的dfs序：dfa,dfb.$Vs$的dfa在$dfa_X$~$dfa_X+siz_X-1$$Vt$的dfb在$dfb_Y$~$dfa_Y+siz_Y-1$建立结构体，按dfa排序，以dfb为权值建立主席树查询$dfa_X$~$dfa_X+siz_X-1$的主席树中值在$dfb_Y$~$dfa_Y+siz_Y-1$之间的个数。若为0则输出0，否则输出1.解毕。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;const int N=8e5+5;const int T=N&lt;&lt;4;int n,m,q,fi[N],ne[N],to[N],tot;int dfa[N],dfb[N],sia[N],sib[N];void add(int x,int y)&#123;ne[++tot]=fi[x];to[tot]=y;fi[x]=tot;&#125;void ad(int x,int y)&#123;add(x,y);add(y,x);&#125;struct kruskal&#123; int type,fk[N],nk[N],tk[N],tok; int fa[N],jp[N][20],rt,dfn[N],cnt,siz[N]; void adk(int x,int y)&#123;nk[++tok]=fk[x];tk[tok]=y;fk[x]=tok;&#125; int fd(int x) &#123; if(x!=fa[x])fa[x]=fd(fa[x]); return fa[x]; &#125; void dfs(int x) &#123; dfn[x]=++cnt;siz[x]=1; for(int i=fk[x];i;i=nk[i]) &#123; int y=tk[i]; jp[y][0]=x; dfs(y); siz[x]+=siz[y]; &#125; &#125; void build() &#123; for(int i=1;i&lt;=n;i++)fa[i]=i; if(type==1) for(int x=n;x;x--) for(int i=fi[x];i;i=ne[i]) &#123; int y=to[i]; if(y&gt;x) &#123; int fx=fd(x),fy=fd(y); if(fx==fy)continue; fa[fy]=fx; adk(fx,fy); &#125; &#125; else for(int x=1;x&lt;=n;x++) for(int i=fi[x];i;i=ne[i]) &#123; int y=to[i]; if(y&lt;x) &#123; int fx=fd(x),fy=fd(y); if(fx==fy)continue; fa[fy]=fx; adk(fx,fy); &#125; &#125; cnt=0; rt=fd(1); dfs(rt); for(int j=1;j&lt;=18;j++) for(int i=1;i&lt;=n;i++) jp[i][j]=jp[jp[i][j-1]][j-1]; &#125; int lca(int x,int y) &#123; for(int i=18;i&gt;=0;i--) &#123; if(type==1) &#123; if(jp[x][i]&gt;=y) x=jp[x][i]; &#125; else &#123; if(jp[x][i]&lt;=y &amp;&amp; jp[x][i]) x=jp[x][i]; &#125; &#125; return x; &#125;&#125;A,B;struct DFN&#123; int a,b;&#125;ss[N];bool cmp(DFN x,DFN y)&#123;return x.a&lt;y.a;&#125;int ls[T],rs[T],tr[T],rt[N],t_cnt;void build(int pre,int &amp;now,int l,int r,int x)&#123; now=++t_cnt;tr[now]=tr[pre]+1; if(l==r)return ; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) &#123; rs[now]=rs[pre]; build(ls[pre],ls[now],l,mid,x); &#125; else &#123; ls[now]=ls[pre]; build(rs[pre],rs[now],mid+1,r,x); &#125; return ;&#125;int query(int now1,int now2,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; R&gt;=r) return tr[now2]-tr[now1]; int mid=(l+r)&gt;&gt;1,anss=0; if(L&lt;=mid)anss+=query(ls[now1],ls[now2],l,mid,L,R); if(R&gt;mid)anss+=query(rs[now1],rs[now2],mid+1,r,L,R); return anss;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); int x,y,z,v; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ad(x+1,y+1); &#125; A.type=1; A.build(); B.type=0; B.build(); for(int i=1;i&lt;=n;i++) &#123; dfa[i]=A.dfn[i];sia[i]=A.siz[i]; dfb[i]=B.dfn[i];sib[i]=B.siz[i]; ss[i].a=dfa[i]; ss[i].b=dfb[i]; &#125; sort(ss+1,ss+n+1,cmp); for(int i=1;i&lt;=n;i++) build(rt[i-1],rt[i],1,n,ss[i].b); for(int i=1;i&lt;=q;i++) &#123; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;v); x++;y++;z++;v++; x=A.lca(x,z); y=B.lca(y,v); if(query(rt[dfa[x]-1],rt[dfa[x]+sia[x]-1],1,n,dfb[y],dfb[y]+sib[y]-1)) puts("1"); else puts("0"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>kruskal</tag>
        <tag>线段树</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
</search>
